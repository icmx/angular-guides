# Структура Angular-проекта

> *Небольшое, но достаточно подробное руководство по структурированию проекта на Angular.*

## Примечание

Это руководство следует воспринимать не как истину в последней инстанции, но как набор рекомендаций и хороших практик.

Основано на [официальном стайлгайде Angular](https://angular.io/guide/styleguide) и очень хорошей [статье с itnext.io](https://itnext.io/choosing-the-right-file-structure-for-angular-in-2020-and-beyond-a53a71f7eb05).

## Обзор структуры

Примерно так должна выглядеть структура проекта:

```
<root>/
├── dist/
├── e2e/
├── src/
│   ├── app/ - - - - - - - - - - - - - - - - - - M
│   │   │
│   │   ├── core/- - - - - - - - - - - - - - - - M
│   │   │   └── core.module.ts
│   │   │
│   │   ├── features/
│   │   │   ├── <feature-name-1>/- - - - - - - - M
│   │   │   │   └── <feature-name-1>.module.ts
│   │   │   │
│   │   │   ├── ...,
│   │   │   │
│   │   │   └── <feature-name-N>/- - - - - - - - M
│   │   │       └── <feature-name-N>.module.ts
│   │   │
│   │   ├── shared/- - - - - - - - - - - - - - - M
│   │   │   └── shared.module.ts
│   │   │
│   │   └── app.module.ts
│   │
│   └── assets/
│       ├── files/
│       ├── fonts/
│       └── icons/
│
├── .eslintrc.json
├── angular.json
├── package.json
└── package-lock.json
```

В основе проекта — т.н. *[Модульная директория](#модульная-директория)* (на схеме отмечены символом `M`).

## Модульная директория

*Модульная директория* — это Angular-модуль, разделенный на несколько файлов и субдиректорий следующим образом:

```
<module-name>/
├── components/
├── pages/
├── services/
├── directives/
├── interceptors/
├── pipes/
├── models/
├── types/
├── enums/
├── utils/
├── <module-name>-routing.module.ts
└── <module-name>.module.ts
```

Каждый модуль не обязательно содержит все субдиректории — это зависит от конкретной задачи.

### Субдиректория components

Содержит *компоненты* — переиспользуемые фрагменты для *страниц* из [субдиректории pages](#субдиректория-pages). Примером компонента может быть кнопка, поле для ввода, карточка с данными, фильтр для поиска и т.д.

Каждый компонент располагается в своей собственной субдиректории и обычно разделен на четыре файла:

```
<component-name>/
├── <component-name>.component.html    -- разметка
├── <component-name>.component.scss    -- стили
├── <component-name>.component.spec.ts -- тесты
└── <component-name>.component.ts      -- логика
```

Иногда к этим файлам добавляется еще один — `<component-name>.component.form.ts`:

```
<component-name>/
├── <component-name>.component.form.ts -- форма и ее логика
├── <component-name>.component.html
├── <component-name>.component.scss
├── <component-name>.component.spec.ts
└── <component-name>.component.ts
```

При необходимости, субдиректория определенного компонета может иметь структуру вложенной модульной директории (например, если у компонента довольно сложное устройство). Иногда такой модульный компонент называют *виджетом*:

```
<component-name>/
├── components/
├── services/
├── pipes/
├── models/
└── <component-name>.module.ts
```

> *например, такое может случиться, если в проекте понадобился компонент модального окна — с функциями появления и скрытия через свой сервис*

*Компоненты* нельзя использовать при раутинге.

*Компоненты* должны содержать большую часть логики (в отличие от *страниц*).

*Компоненты* могут содержать инпаты `@Input` и аутпаты `@Output`.

### Субдиректория pages

Содержит *страницы* — компоненты-обертки, отображаемые на весь экран, и при необходимости использующие простые *компоненты* из [субдиректории components](#субдиректория-components).

Файлы *страниц* должны иметь имена `<page-name>-page.component.<extension>`, а классы — `<PageName>PageComponent`. Например:

  - `users-page.component.ts` и `UsersPageComponent { ... }`.
  - `posts-editor-page.component.ts` и `PostsEditorPageComponent { ... }`

*Страницы* должны использоваться только при раутинге.

*Страницы* должны содержать как можно меньше логики (обычно это просто получение данных из *сервисов*).

*Страницы* не должны содержать инпаты `@Input` и аутпаты `@Output`.

### Субдиректории Angular-сущностей

Субдиректории services, directives, interceptors и pipes cодержат *Angular-сущности* — *сервисы*, *директивы*, *интерсепторы* и *пайпы* соответственно.

Каждая *Angular-сущность* должна содержаться в отдельном файле, с именем вида `<name>.<type>.ts`, например:

```
services/
├── access.service.ts
├── roles.service.ts
└── users.service.ts
```

Если для какого-то вида *Angular-сущностей* нужно хранить дополнительные файлы, то каждая сущность отдельным файлом помещается в свою директорию, например:

```
pipes/
├── currency/
│   ├── currency.pipe.ts
│   └── currency.pipe.spec.ts
├── date/
│   ├── date.pipe.ts
│   └── date.pipe.spec.ts
└── role-name/
    ├── role-name.pipe.ts
    └── role-name.pipe.spec.ts
```

Имена классов всех Angular-сущностей содержат в себе тип, например:

```
class AccessService { ... }     // '...Service', т.е. сервис
class SortableDirective { ... } // '...Directive', т.е. директива
class RoleNamePipe { ... }      // '...Pipe', т.е. пайп
```

### Субдиректории вспомогательных сущностей

Директории `models`, `types`, `enums` и `utils` содержат *вспомогательные сущности*, не имеющие непосредственного отношения к Angular:

**`models`** — модели данных, выполненные в виде интерфейсов:

```ts
export interface User {
  id: number;
  fullname: string;
}
```

**`types`** — описания типов:

```ts
export type ValidationErrors = {
    [key: string]: any;
};
```

**`enums`** — сущности-справочники:

```ts
export enum ButtonColor {
  Primary = 'primary',
  Accent = 'accent',
  Warn = 'warn',
}
```

**`utils`** — небольшие функции-утилиты:

```ts
export const isEmpty = (value: any): boolean => {
  return value === undefined || value === null || value.length === 0;
};
```

Каждая *вспомогательная сущность* содержится в отдельном файле вида `<name>.<type>.ts`, например `user.model.ts`, `validation-errors.type.ts`, `button-color.enum.ts`, `is-empty.util.ts` и т.д.

Иногда нужно добавить нестандартные вспомогательные сущности — например, набор функций-валидаторов. В этом случае они добавляются по аналогичной схеме:

```
validators/
├── required.validator.ts
└── format.validator.ts
```

Если для *вспомогательных сущностей* требуются отдельные файлы, то сущности помещаются в дополнительные директории (см. [Субдиректории Angular-сущностей](#субдиректории-Angular-сущностей)).

В отличие от Angular-сущностей, имена вспомогательных сущностей не содержат в себе тип:

```
interface User { ... }
type ValidationError { ... }
const isEmpty { ... }
```

### Файл модуля

Описывает содержимое модуля. Обычно выглядит следующим образом:

```ts
import { NgModule } from '@angular/core';
// ... прочие импорты JavaScript/TypeScript-файлов

@NgModule({
  declarations: [
    // Компоненты, директивы и пайпы, принадлежащие этому модулю.
  ],
  exports: [
    // Компоненты, директивы и пайпы, которые должны быть доступны для
    // внешних модулей при импорте.
  ],
  imports: [
    // Внешние модули, чье содержимое (указанное в exports) должно быть
    // доступно в этом модуле.
  ],
  providers: [
    // Инжектируемые объекты, которые должны быть доступны в этом
    // модуле (обычно это сервисы).
  ],
})
export class ExampleModule {}
```

### Дополнительные модули

Иногда в модульной директории могут находиться несколько файлов модулей — чаще всего это основной модуль и модуль раутинга:

```
<module-name>/
├── <module-name>-routing.module.ts
└── <module-name>.module.ts
```

Иногда к ним может добавиться индексный модуль для большого количества импортов из сторонней библиотеки — например, так:

```
<module-name>/
├── material.module.ts -- индексный модуль для модулей Angular Material
├── <module-name>-routing.module.ts
└── <module-name>.module.ts
```

## Ключевые модульные директории проекта

### Директория app — AppModule

Содержит корневой модуль, обязательно импортирующий CoreModule, а также остальные модули, в зависимости от задачи.

### Директория app/core — CoreModule

В этом модуле содержатся общие *[Angular-сущности](#субдиректории-Angular-сущностей)*, если они:

  - доступны почти всегда и везде (например, сервис авторизации пользователя)
  - инициализируются один раз за все время жизни приложения (например, гвард для проверки прав и доступа к странцие)
  - статичны и не зависят от внешнего контекста (например, страница-заглушка для несуществующего маршрута)

Эта директория также содержит все общие *[вспомогательные сущности](#субдиректории-вспомогательных-сущностей)*, которые явно используются во всем проекте — обычно это общие модели, функции-утилиты и т.д.

CoreModule должен импортироваться *только один раз*, и *только* в AppModule. Это так называемое синглтон-"ядро" приложения и оно не будет нигде *переиспользоваться*, даже потенциально.

CoreModule не должен импортировать другие модули приложения (из app/features и app/shared).

### Директория app/features

Содержит одну или несколько модульных директорий, относящихся к какой-то *фиче* (органиченному участку предметной области проекта).

Например, простое приложение-блог может иметь следующие *фичи*:

```
app
└── features
    ├── posts               -- создание и просмотр постов
    │   └── posts.module.ts
    ├── profile             -- управление своим профилем
    │   └── profile.module.ts
    └── admin               -- администрирование (управление сайтом)
        └── admin.module.ts
```

Каждой из этих фич необходим собственный модуль.

Модули фич не могут импортировать другие модули приложения, кроме SharedModule.

### Директория app/shared — SharedModule

В этом модуле содержатся общие *[Angular-сущности](#субдиректории-Angular-сущностей)*, если они:

  - доступны в каких-то участках приложения, но, скорее всего, не во всех (например, компонент-поле для ввода с кастомной логикой)
  - динамичны и зависят от внешнего контекста (например, компонент-список превьюшек со ссылками, где внешний контекст — это массив сущностей, который может меняться)
  - потенциально могут быть "извлечены" из приложения и оформлены отдельной библиотекой (например, пайп для конвертации и упрощения чисел — "1000000 to 1M")

## Декомпозиция на модули. Практический пример

На первый взгляд задача может показаться простой, но лучше рассмотреть ее на подробном примере.

Предположим, что у нас есть приложение для документооборота. Из технического задания получилась такая иерархия:

```ts
// В системе есть некие документы-акты:
export interface Act {
  id: number;

  // у каждого акта есть несколько исполнителей:
  executors: Executor[];
}

export interface Executor {
  id: number;

  // а у каждого исполнителя есть несколько выплат:
  payments: Payment[];
}

export interface Payment {
  id: number;

  // и каждая выплата может иметь статус --
  // справочник на три знчения:
  // "Завершена", "Частично завершена" и "Не завершена"
  status: PaymentStatus;
}

export interface PaymentStatus {
  id: number;
  label: string;
}

// А еще в этой системе есть пользователи, которые в ней будут работать
// (пользователи никак не связаны с актами и прочим содержимым системы)
export interface User {
  id: string;
  isAdmin: boolean;
}
```

Исходя из этой иерархии, уже можно выделить четыре *фичи*:

```
app/
└── features/
    ├── acts/
    │   └── acts.module.ts
    ├── executors/
    │   └── executors.module.ts
    ├── payments/
    │   └── payments.module.ts
    └── users/
        └── users.module.ts
```

Подумаем о пользовательском опыте. Что юзеру нужно видеть?

  - Главный экран — меню:
    - Есть ссылка на список актов
    - Есть ссылка на список пользователей
  - При просмотре списка актов:
    - Можно отфильтровать акты по параметрам
    - Видно список актов — либо всех в системе, либо отфильтрованных
    - Можно выбрать акт из списка и перейти к странице его редактирования
  - При редактировании акта:
    - Можно менять поля акта
    - Видно список исполнителей, принадлежащих этому акту.
    - Можно выбрать исполнителя из списка и перейти к странице его редактирования
  - При редактировании исполнителя:
    - Можно менять поля исполнителя
    - Видно список платежей, принадлежащих этому исполнителю
    - Можно выбрать платеж из списка и перейти к странице его редактирования
  - При редактировании платежа:
    - Можно менять поля платежа
  - При просмотре списка пользователей
    - Можно отфильтровать пользователей по параметрам
    - Видно список пользователей — либо всех в системе, либо отфильтрованных
    - Можно выбрать пользователя из списка и перейти к его редактированию в модальном окне

Теперь ясно, какие компоненты и страницы нужны каждой фиче:

```
app/
└── features/
    ├── acts/
    │   ├── components/
    │   │   ├── acts-list
    │   │   ├── acts-filter
    │   │   └── acts-editor
    │   ├── pages/
    │   │   ├── acts-list-page
    │   │   └── acts-editor-page
    │   └── acts.module.ts
    ├── executors/
    │   ├── components/
    │   │   └── executors-editor
    │   ├── pages/
    │   │   └── executors-editor-page
    │   └── executors.module.ts
    ├── payments/
    │   ├── components/
    │   │   └── payments-editor
    │   ├── pages
    │   │   └── payments-editor-page
    │   └── payments.module.ts
    └── users/
        ├── components/
        │   ├── users-list
        │   ├── users-filter
        │   └── users-editor
        ├── pages/
        │   └── users-list-page
        └── users.module.ts
```

Далее, что делать с главным экраном-меню? К какой фиче это отнести? Этот вопрос решается через CoreModule, т.к. меню слабо относится к предметной области, но является неотъемлемой частью приложения, используемой при этом явно в одном месте, и вне контекста. Просто добавим в CoreModule страницу HomePage, а также страницы для типичных ошибок — NotFound и AccessDenied (они нам точно понадобятся).

```
app
└── core
    └── pages
        ├── access-denied-page
        ├── not-found-page
        └── home-page
```

Что делать с вложенными списками? Например, в редакторе актов `acts-editor` нужен список исполнителей `act.executors` — к какой фиче будет принадлежать такой компонент-список?

Этот вопрос можно решить двумя способами. Первый способ — не оформлять вложенный список отдельным компонентом, а просто оставить как есть, например:

```html
<!-- В разметке app/features/acts/components/acts-editor: -->

<h1>Редактор акта</h1>
<!-- (поля относящиеся к акту act.*) -->

<hr />
<h2>Исполнители акта</h2>
<!-- здесь начинается вложенный список: -->
<ul>
  <li *ngFor="let executor of act.executors">
    <a [routerLink]="[act.id, 'executors', executor.id]">
      {{ executor.fullname }}, добавлен {{ executor.created | date }}
    </a>
  </li>
</ul>
```

Этот способ не рекомендуется, но применим, если:

  - Вложенный список не используется нигде, кроме компонента-родителя, **И**
  - вложенный список является достаточно простым. Например, визуально это просто несколько карточек-ссылок.

Второй способ решения проблемы — оформить список в отдельный компонент и вынести в SharedModule. Для нашей ситуации будет выглядеть так:

```
app
└── shared
    └── components
        ├── executors-list -- список превьюшек для Executor (act.executors)
        └── payments-list  -- список превьюшек для Payment (executor.payments)
```

Такой вариант всегда более предпочтителен, и особо рекомендуется, если:

  - Вложенный список может (или потенциально будет) использоваться в нескольких местах приложения, **ИЛИ**
  - для вложенного списка нужно какое-то сложное оформление или логика.

Осталось понять, где будут располагаться *сервисы*. Очевидно, что для каждой фичи нужен как минимум один сервис получения данных:

```
app/
└── features/
    ├── acts/
    │   └── services/
    │       └── acts.service.ts
    ├── executors/
    │   └── services/
    │       └── executors.service.ts
    ├── payments/
    │   └── services/
    │       └── payments.service.ts
    └── users/
        └── services/
            └── users.service.ts
```

Теперь вспомним сущность `Payment` и его поле `status`:

```ts
export interface Payment {
  id: number;
  status: PaymentStatus;
}

export interface PaymentStatus {
  id: number;
  label: string;
}
```

На момент разработки известно, что `Payment.status`  — это просто справочник на три значения ("Завершена", "Частично завершена" и "Не завершена"). В будущем, однако, легко может произойти следующее:

  - Эти значения могут поменяться
  - Заказчик может попросить доработать приложение — сделать редактор значений, чтобы менять их самостоятельно

Таким образом, нам точно нужен дополнительный сервис — `payment-statuses.service.ts`. Поместим его в SharedModule, т.к. потенциально сервис может использоваться в разных фичах: сейчас это только фича PaymentsModule, но в будущем может появиться фича редактирования статусов платежа.

```
app/
└── shared/
    └── services/
        └── payment-statuses.service.ts
```

Нам также наверняка понадобится сервис авторизации и получения прав, а также несколько гвардов. Т.к. эти Angular-сущности будут использоваться практически везде в приложении, отнесем их к CoreModule:

```
app/
└── core/
    ├── services/
    │   └── access.service.ts
    └── guards/
        ├── authorized.guard.ts -- пропускает только авторизованных
        └── admin.guard.ts      -- пропускает только администраторов
```

Готово! У нас получилась следующая структура:

```
app/
├── core/
│   ├── guards/
│   │   ├── authorized.guard.ts
│   │   └── admin.guard.ts
│   ├── pages
│   │   ├── access-denied-page
│   │   ├── not-found-page
│   │   └── home-page
│   ├── services/
│   │   └── access.service.ts
│   └── core.module.ts
├── features/
│   ├── acts/
│   │   ├── components/
│   │   │   ├── acts-list
│   │   │   ├── acts-filter
│   │   │   └── acts-editor
│   │   ├── pages/
│   │   │   ├── acts-list-page
│   │   │   └── acts-editor-page
│   │   ├── services
│   │   │   └── acts.service.ts
│   │   └── acts.module.ts
│   ├── executors/
│   │   ├── components/
│   │   │   └── executors-editor
│   │   ├── pages/
│   │   │   └── executors-editor-page
│   │   ├── services/
│   │   │   └── executors.service.ts
│   │   └── executors.module.ts
│   ├── payments/
│   │   ├── components/
│   │   │   └── payments-editor
│   │   ├── pages
│   │   │   └── payments-editor-page
│   │   ├── services/
│   │   │   └── payments.service.ts
│   │   └── payments.module.ts
│   └── users/
│       ├── components/
│       │   ├── users-list
│       │   ├── users-filter
│       │   └── users-editor
│       ├── pages/
│       │   └── users-list-page/
│       ├── services/
│       │   └── users.service.ts
│       └── users.module.ts
└── shared/
    ├── components
    │   ├── executors-list
    │   └── payments-list
    ├── services/
    │   └── payment-statuses.service.ts
    └── shared.module.ts
```

## Прочие файлы и директории

**`src/assets`** — бинарные файлы-ассеты, которые будут меняться вне процесса разработки. Обычно сюда входят следующие директории:

  - `files` — файлы для загрузки пользователями (например, файл с инструкцией)
  - `fonts` — подключаемые шрифты
  - `icons` — подключаемые значки

**`favicon.ico`** — значок приложения

**`src/index.html`** — индексная страница приложения. Обычно имеет следующий вид:

```html
<!doctype html>
<html lang="ru"> <!-- рекомендуется указать язык приложения -->
  <head>
    <!-- кодировка -- обязательно UTF-8, обязательно в начале -->
    <meta charset="utf-8" />

    <!--
      базовая директория -- обычно `/`, но в завимости от адреса,
      может отличаться
    -->
    <base href="/" />

    <!-- адаптивный вьюпорт, значок и название -- лучше указать -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <title>Название приложения</title>

    <!-- прочие ссылки будут подключаться автоматически при сборке -->
  </head>
  <body>
    <!-- корневой компонент приложения -->
    <app-root></app-root>
  </body>
</html>
```

**`src/styles.scss`** — стили, применяемые ко всему приложению

**`angular.json`** — настройки Angular-проекта

**`package.json`** — общие настройки NPM. Angular-проект должен содержать следующие скрипты:

```json
"scripts": {
  "ng":               "ng",
  "start":            "echo Starting... && ng serve",
  "start:staging":    "ng serve --configuration=staging",
  "build":            "ng build",
  "build:production": "ng build --configuration=production",
  "test":             "ng test",
  "test:headless":    "ng test --watch=false --browsers=ChromeHeadless",
  "lint":             "ng lint",
}
```

Если проект имеет пакеты-зависимости, то они устанавливаются через `npm install --save <package-name>` и сохраняются в `"dependencies"`.

Пакеты-зависимости, необходимые только во время разработки, устанавливаются через `npm install --save-dev <package-name>` и сохраняются в `"devDependencies"`.

**`package-lock.json`** — дерево зависимостей пакетов. Этот файл необходимо коммитить, наравне с остальными.
